-- =========================================
-- Supplier Pricing Pipeline (DB installer)
-- Fixed version - compatible with existing products table
-- =========================================

-- Enable extensions
CREATE EXTENSION IF NOT EXISTS pgcrypto;

-- Skip products table since you already have it
-- create table if not exists products (...) -- SKIPPED

-- Product configurations to extend your existing products
CREATE TABLE IF NOT EXISTS product_configs (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  product_id uuid REFERENCES products(id),
  attrs jsonb NOT NULL,
  dims jsonb NOT NULL,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

-- Suppliers table (renamed to avoid conflict with your existing 'supplier' table)
CREATE TABLE IF NOT EXISTS suppliers (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  name text NOT NULL,
  currency text DEFAULT 'USD',
  incoterm text DEFAULT 'FOB'
);

-- Supplier rate cards
CREATE TABLE IF NOT EXISTS supplier_rate_cards (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  supplier_id uuid REFERENCES suppliers(id),
  family text NOT NULL,
  base jsonb NOT NULL,
  freight jsonb NOT NULL DEFAULT '{"mode":"ocean","per_kg":0.45,"min":350}',
  duty numeric NOT NULL DEFAULT 0,
  fx_to_usd numeric NOT NULL DEFAULT 1.0,
  active boolean DEFAULT true,
  UNIQUE (supplier_id, family, active)
);

-- Create custom types
DO $$ BEGIN CREATE TYPE rule_action AS ENUM ('adder','multiplier','override'); EXCEPTION WHEN duplicate_object THEN NULL; END $$;
DO $$ BEGIN CREATE TYPE rule_basis AS ENUM ('per_unit','per_m2','per_kg','per_order','per_shipment'); EXCEPTION WHEN duplicate_object THEN NULL; END $$;

-- Pricing rules
CREATE TABLE IF NOT EXISTS pricing_rules (
  id bigserial PRIMARY KEY,
  supplier_id uuid NULL,
  family text NULL,
  condition jsonb NOT NULL,
  action rule_action NOT NULL,
  basis rule_basis NOT NULL,
  value numeric NOT NULL,
  notes text,
  priority int DEFAULT 100,
  effective_from date DEFAULT now(),
  effective_to date DEFAULT '2999-12-31'
);

-- Margin tiers
CREATE TABLE IF NOT EXISTS margin_tiers (
  id bigserial PRIMARY KEY,
  family text NOT NULL,
  min_qty int NOT NULL,
  max_qty int NOT NULL,
  target_margin numeric NOT NULL
);

-- Upload tracking tables
CREATE TABLE IF NOT EXISTS supplier_uploads (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  supplier_id uuid NOT NULL REFERENCES suppliers(id),
  file_path text NOT NULL,
  file_name text NOT NULL,
  mime_type text,
  uploaded_by uuid,
  status text NOT NULL DEFAULT 'uploaded',
  detected_format text,
  pages int,
  notes text,
  created_at timestamptz DEFAULT now()
);

CREATE TABLE IF NOT EXISTS supplier_quote_raw_rows (
  upload_id uuid REFERENCES supplier_uploads(id) ON DELETE CASCADE,
  row_index int,
  page int,
  raw jsonb,
  PRIMARY KEY (upload_id, row_index)
);

CREATE TABLE IF NOT EXISTS supplier_mapping_profiles (
  id bigserial PRIMARY KEY,
  supplier_id uuid NOT NULL REFERENCES suppliers(id),
  profile_name text NOT NULL DEFAULT 'default',
  header_map jsonb NOT NULL,
  constant_map jsonb,
  created_at timestamptz DEFAULT now(),
  UNIQUE (supplier_id, profile_name)
);

CREATE TABLE IF NOT EXISTS supplier_rate_card_staging (
  upload_id uuid PRIMARY KEY REFERENCES supplier_uploads(id) ON DELETE CASCADE,
  supplier_id uuid NOT NULL REFERENCES suppliers(id),
  family text NOT NULL,
  base jsonb NOT NULL,
  freight jsonb NOT NULL,
  duty numeric NOT NULL DEFAULT 0,
  fx_to_usd numeric NOT NULL DEFAULT 1,
  derived_from jsonb
);

CREATE TABLE IF NOT EXISTS supplier_rate_card_staging_rules (
  upload_id uuid REFERENCES supplier_uploads(id) ON DELETE CASCADE,
  rule jsonb,
  idx int GENERATED BY DEFAULT AS IDENTITY,
  PRIMARY KEY (upload_id, idx)
);

-- =========================================
-- Helper Functions
-- =========================================

-- Geometry & weight helpers
CREATE OR REPLACE FUNCTION fn_layout_area_m2(family text, dims jsonb)
RETURNS numeric LANGUAGE plpgsql AS $$
DECLARE 
  w numeric; h numeric; g numeric; d numeric; l numeric;
BEGIN
  w := coalesce((dims->>'width_mm')::numeric,0);
  h := coalesce((dims->>'height_mm')::numeric,0);
  g := coalesce((dims->>'gusset_mm')::numeric,0);
  d := coalesce((dims->>'diameter_mm')::numeric,0);
  l := coalesce((dims->>'length_mm')::numeric,0);
  IF (dims ? 'area_m2') THEN RETURN (dims->>'area_m2')::numeric; END IF;
  CASE family
    WHEN 'bag' THEN RETURN ((w*h*2)+(g*h*2))/1e6;
    WHEN 'cup' THEN RETURN (3.1415926535 * d * h)/1e6;
    WHEN 'carton' THEN RETURN (2*((w*l)+(l*h)+(w*h)))/1e6;
    ELSE RETURN null;
  END CASE;
END $$;

CREATE OR REPLACE FUNCTION fn_weight_kg(dims jsonb, area_m2 numeric)
RETURNS numeric LANGUAGE plpgsql AS $$
DECLARE 
  gsm numeric := null; 
  thickness_um numeric := null; 
  density_g_cm3 numeric := null;
BEGIN
  IF area_m2 IS NULL THEN RETURN NULL; END IF;
  IF dims ? 'weight_kg' THEN RETURN (dims->>'weight_kg')::numeric; END IF;
  IF dims ? 'gsm' THEN 
    gsm := (dims->>'gsm')::numeric; 
    RETURN area_m2 * gsm / 1000.0; 
  END IF;
  IF (dims ? 'thickness_um') AND (dims ? 'density_g_cm3') THEN
    thickness_um := (dims->>'thickness_um')::numeric;
    density_g_cm3 := (dims->>'density_g_cm3')::numeric;
    RETURN area_m2 * (thickness_um/1e6) * (density_g_cm3*1000.0);
  END IF;
  RETURN NULL;
END $$;

CREATE OR REPLACE FUNCTION fn_pretty_round(x numeric)
RETURNS numeric LANGUAGE plpgsql AS $$
DECLARE c numeric;
BEGIN 
  c := round(x::numeric, 2);
  IF c >= 1 THEN RETURN floor(c) + 0.95; ELSE RETURN round(c,2); END IF;
END $$;

-- =========================================
-- Price Computation Functions
-- =========================================

-- Price computation type
CREATE TYPE computed_price AS (
  qty int, 
  supplier_id uuid, 
  landed_unit_cost numeric,
  target_margin numeric, 
  sell_unit_price numeric, 
  breakdown jsonb
);

-- Simplified compute_price function for your existing products
CREATE OR REPLACE FUNCTION compute_price_simple(
  p_product_id uuid, 
  p_supplier_id uuid, 
  p_qty int
)
RETURNS computed_price LANGUAGE plpgsql AS $$
DECLARE
  landed_unit numeric;
  margin numeric := 0.30;
  sell numeric;
BEGIN
  -- Simplified calculation - you can enhance this based on your needs
  landed_unit := 10.00; -- Base price, replace with actual calculation
  sell := landed_unit / (1 - margin);
  
  RETURN ROW(
    p_qty,
    p_supplier_id,
    landed_unit,
    margin,
    sell,
    '{}'::jsonb
  )::computed_price;
END $$;

-- =========================================
-- RPCs for Upload Processing
-- =========================================

CREATE OR REPLACE FUNCTION inbox_register_upload(
  p_supplier_id uuid, 
  p_file_path text, 
  p_file_name text, 
  p_mime text
)
RETURNS uuid LANGUAGE sql AS $$
  INSERT INTO supplier_uploads (supplier_id, file_path, file_name, mime_type, uploaded_by)
  VALUES (p_supplier_id, p_file_path, p_file_name, p_mime, auth.uid())
  RETURNING id;
$$;

-- Normalize raw rows into staging
CREATE OR REPLACE FUNCTION normalize_upload_to_staging(
  p_upload_id uuid, 
  p_family text, 
  p_profile_id bigint
)
RETURNS void LANGUAGE plpgsql AS $$
DECLARE 
  m jsonb; c jsonb; u supplier_uploads; first_row jsonb;
  material_per_m2 numeric := null; 
  print_per_m2 numeric := null;
  included_colors int := 1; 
  setup_fee numeric := 0; 
  plate_fee numeric := 0; 
  waste_factor numeric := 0.05;
  freight jsonb := '{"mode":"ocean","per_kg":0.45,"min":350}'; 
  duty numeric := 0;
BEGIN
  SELECT * INTO u FROM supplier_uploads WHERE id=p_upload_id;
  SELECT header_map, coalesce(constant_map,'{}'::jsonb) INTO m, c 
    FROM supplier_mapping_profiles WHERE id=p_profile_id;
  SELECT raw->'cols' INTO first_row FROM supplier_quote_raw_rows 
    WHERE upload_id=p_upload_id ORDER BY row_index ASC LIMIT 1;
  
  IF first_row IS NOT NULL AND m IS NOT NULL THEN
    material_per_m2 := nullif((first_row->>(m->>'material_per_m2')),'')::numeric;
    print_per_m2 := nullif((first_row->>(m->>'print_per_m2')),'')::numeric;
    included_colors := coalesce(nullif((first_row->>(m->>'included_colors')),'')::int, included_colors);
    setup_fee := coalesce(nullif((first_row->>(m->>'setup_fee')),'')::numeric, setup_fee);
    plate_fee := coalesce(nullif((first_row->>(m->>'plate_fee')),'')::numeric, plate_fee);
    waste_factor := coalesce(nullif((first_row->>(m->>'waste_factor')),'')::numeric, waste_factor);
  END IF;
  
  INSERT INTO supplier_rate_card_staging(
    upload_id, supplier_id, family, base, freight, duty, fx_to_usd, derived_from
  )
  VALUES (
    p_upload_id, u.supplier_id, p_family,
    jsonb_build_object(
      'material_per_m2',material_per_m2,
      'print_per_m2',print_per_m2,
      'included_colors',included_colors,
      'setup_fee',setup_fee,
      'plate_fee',plate_fee,
      'waste_factor',waste_factor
    ),
    freight, duty, 1.0,
    jsonb_build_object('source','supplier_quote_raw_rows','profile_id',p_profile_id)
  )
  ON CONFLICT (upload_id) DO UPDATE 
  SET family=excluded.family, 
      base=excluded.base, 
      freight=excluded.freight, 
      duty=excluded.duty, 
      derived_from=excluded.derived_from;
  
  UPDATE supplier_uploads SET status='normalized' WHERE id=p_upload_id;
END $$;

-- Publish staging to active rate card
CREATE OR REPLACE FUNCTION publish_staging_rate_card(p_upload_id uuid)
RETURNS uuid LANGUAGE plpgsql AS $$
DECLARE 
  s supplier_rate_card_staging; 
  new_id uuid;
BEGIN
  SELECT * INTO s FROM supplier_rate_card_staging WHERE upload_id=p_upload_id;
  IF NOT FOUND THEN RAISE EXCEPTION 'no staging found for %', p_upload_id; END IF;
  
  UPDATE supplier_rate_cards SET active=false 
    WHERE supplier_id=s.supplier_id AND family=s.family AND active=true;
  
  INSERT INTO supplier_rate_cards(supplier_id,family,base,freight,duty,fx_to_usd,active)
  VALUES (s.supplier_id, s.family, s.base, s.freight, s.duty, s.fx_to_usd, true)
  RETURNING id INTO new_id;
  
  UPDATE supplier_uploads SET status='approved' WHERE id=p_upload_id;
  RETURN new_id;
END $$;

-- =========================================
-- RLS Policies (Fixed - no IF NOT EXISTS)
-- =========================================

-- Enable RLS on tables
ALTER TABLE supplier_uploads ENABLE ROW LEVEL SECURITY;
ALTER TABLE supplier_quote_raw_rows ENABLE ROW LEVEL SECURITY;
ALTER TABLE supplier_mapping_profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE supplier_rate_card_staging ENABLE ROW LEVEL SECURITY;
ALTER TABLE supplier_rate_card_staging_rules ENABLE ROW LEVEL SECURITY;

-- Drop existing policies if they exist (safe to run multiple times)
DROP POLICY IF EXISTS "auth_read_uploads" ON supplier_uploads;
DROP POLICY IF EXISTS "auth_write_uploads" ON supplier_uploads;
DROP POLICY IF EXISTS "auth_update_uploads" ON supplier_uploads;
DROP POLICY IF EXISTS "auth_read_raw" ON supplier_quote_raw_rows;
DROP POLICY IF EXISTS "auth_write_raw" ON supplier_quote_raw_rows;
DROP POLICY IF EXISTS "auth_read_mapping" ON supplier_mapping_profiles;
DROP POLICY IF EXISTS "auth_write_mapping" ON supplier_mapping_profiles;
DROP POLICY IF EXISTS "auth_read_staging" ON supplier_rate_card_staging;
DROP POLICY IF EXISTS "auth_write_staging" ON supplier_rate_card_staging;
DROP POLICY IF EXISTS "auth_read_staging_rules" ON supplier_rate_card_staging_rules;
DROP POLICY IF EXISTS "auth_write_staging_rules" ON supplier_rate_card_staging_rules;

-- Create new policies
CREATE POLICY "auth_read_uploads" ON supplier_uploads 
  FOR SELECT TO authenticated USING (true);
CREATE POLICY "auth_write_uploads" ON supplier_uploads 
  FOR INSERT TO authenticated WITH CHECK (true);
CREATE POLICY "auth_update_uploads" ON supplier_uploads 
  FOR UPDATE TO authenticated USING (true);

CREATE POLICY "auth_read_raw" ON supplier_quote_raw_rows 
  FOR SELECT TO authenticated USING (true);
CREATE POLICY "auth_write_raw" ON supplier_quote_raw_rows 
  FOR INSERT TO authenticated WITH CHECK (true);

CREATE POLICY "auth_read_mapping" ON supplier_mapping_profiles 
  FOR SELECT TO authenticated USING (true);
CREATE POLICY "auth_write_mapping" ON supplier_mapping_profiles 
  FOR INSERT TO authenticated WITH CHECK (true);

CREATE POLICY "auth_read_staging" ON supplier_rate_card_staging 
  FOR SELECT TO authenticated USING (true);
CREATE POLICY "auth_write_staging" ON supplier_rate_card_staging 
  FOR INSERT TO authenticated WITH CHECK (true);
CREATE POLICY "auth_update_staging" ON supplier_rate_card_staging 
  FOR UPDATE TO authenticated USING (true);

CREATE POLICY "auth_read_staging_rules" ON supplier_rate_card_staging_rules 
  FOR SELECT TO authenticated USING (true);
CREATE POLICY "auth_write_staging_rules" ON supplier_rate_card_staging_rules 
  FOR INSERT TO authenticated WITH CHECK (true);

-- =========================================
-- Storage Policies (Run in Storage section)
-- =========================================
-- Note: These need to be created in the Supabase Storage UI or via separate SQL
-- 1. Create bucket 'supplier-quotes' as private
-- 2. Add these policies in the Storage policies section

-- =========================================
-- Sample Data (Optional)
-- =========================================

-- Insert default margin tiers
INSERT INTO margin_tiers(family,min_qty,max_qty,target_margin)
SELECT x.* FROM (VALUES
  ('bag',1,9999,0.38),
  ('bag',10000,19999,0.34),
  ('bag',20000,9999999,0.30),
  ('cup',1,9999,0.32),
  ('cup',10000,19999,0.30),
  ('cup',20000,9999999,0.28),
  ('carton',1,9999,0.35),
  ('carton',10000,19999,0.32),
  ('carton',20000,9999999,0.28),
  ('other',1,9999999,0.30)
) AS x(family,min_qty,max_qty,target_margin)
ON CONFLICT DO NOTHING;

-- Sample suppliers (optional - comment out if not needed)
/*
INSERT INTO suppliers (name, currency, incoterm)
VALUES 
  ('China Packaging Co', 'USD', 'FOB'),
  ('Vietnam Print Solutions', 'USD', 'CIF'),
  ('Local Quick Print', 'USD', 'EXW')
ON CONFLICT DO NOTHING;
*/

-- =========================================
-- Success Message
-- =========================================
DO $$
BEGIN
  RAISE NOTICE 'Supplier pricing schema installed successfully!';
  RAISE NOTICE 'Next steps:';
  RAISE NOTICE '1. Create storage bucket: supplier-quotes (private)';
  RAISE NOTICE '2. Deploy Edge Function for file processing';
  RAISE NOTICE '3. Add suppliers via the web interface';
END $$;